<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Memory Game for Ben — HTML5</title>
  <style>
    :root{
      --bg:#0b2239;
      --narbe-orange:#ff5c00;
      --narbe-blue:#5bb0ff;
      --panel:#1a2332;
      --text:#e8f0ff;
      --muted:#b6c6dd;
      --yellow:#ffd400;
      --gray:#4a5568;
      --dark-gray:#2d3748;
      --green:#48bb78;
      --magenta:#ed64a6;
      --purple:#9f7aea;
      --cyan:#4dc0b5;
      --red:#fc8181;
      --radius:18px;
      --ring:0 0 0 4px rgba(255,212,0,.65), 0 10px 25px rgba(0,0,0,.35);
    }
    html,body{height:100%; overflow:hidden; margin:0; padding:0;}
    
    /* Mobile viewport fix */
    @supports (-webkit-touch-callout: none) {
      /* iOS Safari */
      html, body {
        height: -webkit-fill-available;
      }
    }
    
    body{
      margin:0; 
      background: radial-gradient(1200px 800px at 10% -10%, rgba(255,92,0,.2), transparent),
                  radial-gradient(1200px 800px at 110% 10%, rgba(91,176,255,.2), transparent),
                  linear-gradient(180deg, #0a1929 0%, #1a2332 100%); 
      color:var(--text); 
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji"; 
    }
    .app{
      position:fixed; 
      inset:0; 
      display:flex; 
      flex-direction:column; 
      overflow:hidden; /* Never allow scrollbars */
      height: 100vh;
      height: 100dvh;
    }
    .topbar{
      display:flex; 
      justify-content:center; 
      align-items:center; 
      background:rgba(0,0,0,.2); 
      border-bottom:2px solid rgba(91,176,255,.2);
      color:#e8f0ff; 
      padding:.5rem 1rem;
      flex-shrink: 0;
      min-height: 50px;
      box-sizing: border-box;
      gap: 1rem;
      position: relative;
    }
    .topbar-title{
      font-weight:800; 
      font-size:18px;
      background: linear-gradient(90deg, var(--narbe-orange), var(--narbe-blue));
      -webkit-background-clip:text; 
      background-clip:text; 
      color:transparent;
      text-shadow: 0 2px 10px rgba(91,176,255,.3);
      flex-shrink: 0;
      position: absolute;
      left: 1rem;
    }
    .topbar-score{
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 2rem;
      font-size: 14px;
      font-weight: 600;
    }
    .score-item-header{
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
    }
    .score-label-header{
      font-size: 10px;
      opacity: 0.8;
      text-transform: uppercase;
    }
    .score-value-header{
      font-size: 16px;
      font-weight: 800;
      color: var(--yellow);
    }
    .screen{
      flex:1; 
      display:flex; 
      align-items:center; 
      justify-content:center; 
      padding:0.5rem;
      overflow:hidden; /* Never allow scrollbars */
      min-height: 0;
    }
    .center{
      width:100%;
      height:100%; 
      display:flex; 
      flex-direction:column; 
      align-items:center; 
      justify-content:center; 
      overflow:hidden; /* Never allow scrollbars */
      padding:0.5rem; 
      box-sizing: border-box;
    }
    .title{
      display: none; /* Remove title from main area - now in header */
    }
    .main-menu-container{
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      padding: 1rem;
      box-sizing: border-box;
    }
    .instructions-and-buttons{
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      width: 100%;
      height: 100%;
    }
    .menu-buttons-container{
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      flex-shrink: 0;
    }
    @keyframes gradient {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    .instructions {
      background: linear-gradient(135deg, rgba(91,176,255,.1), rgba(255,92,0,.1));
      border: 2px solid rgba(91,176,255,.3);
      border-radius: var(--radius);
      padding: 0.8rem 1rem;
      margin: 0;
      max-width: 400px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.85rem;
      flex-shrink: 1; /* Allow shrinking */
      min-width: 250px;
    }
    .instructions:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(91,176,255,.2);
      border-color: rgba(91,176,255,.5);
    }
    .instructions.scan {
      border-color: var(--yellow);
      background: linear-gradient(135deg, rgba(255,212,0,.2), rgba(255,140,0,.2));
      box-shadow: 0 0 30px rgba(255,212,0,.4);
    }
    .instructions h3 {
      color: var(--narbe-blue);
      margin: 0 0 .5rem;
      font-size: 1rem;
    }
    .instructions p {
      color: var(--text);
      line-height: 1.4;
      margin: .3rem 0;
      font-size: .8rem;
    }

    .btn{
      appearance:none; 
      border:2px solid rgba(91,176,255,.3); 
      background: linear-gradient(135deg, rgba(91,176,255,.15), rgba(255,92,0,.15)); 
      color:white; 
      padding:0.8rem 2rem; /* Increased padding */
      border-radius:var(--radius); 
      font-size:clamp(1rem,2vw,1.2rem); /* Increased font size */
      font-weight: 600;
      margin:.5rem 0; /* Increased margin */
      cursor:pointer;
      transition: all .3s ease;
      box-shadow: 0 6px 20px rgba(0,0,0,.25);
      text-transform: uppercase;
      letter-spacing: 1px;
      min-width: 200px; /* Increased min width */
      flex-shrink: 0;
    }
    .btn:hover{
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 14px 34px rgba(91,176,255,.3);
      background: linear-gradient(135deg, rgba(91,176,255,.25), rgba(255,92,0,.25));
      border-color: rgba(91,176,255,.5);
    }
    .btn.scan{
      background: linear-gradient(135deg, var(--yellow), #ffab00); 
      color:#0b2239; 
      box-shadow:var(--ring);
      border-color: rgba(255,212,0,.5);
      animation: pulse 1.5s ease infinite;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    .score-panel{
      display: flex;
      gap: 1.5rem; /* Increased gap */
      justify-content: center;
      align-items: center;
      margin-bottom:1rem; /* Increased margin */
      background: linear-gradient(135deg, rgba(0,0,0,.3), rgba(0,0,0,.1)); 
      padding:.8rem 1.5rem; /* Increased padding */
      border-radius:16px;
      border:2px solid rgba(91,176,255,.2);
      box-shadow: inset 0 2px 10px rgba(0,0,0,.3);
      flex-shrink: 0;
    }
    .score-item {
      text-align: center;
    }
    .score-label {
      font-size: 0.8rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .score-value {
      font-size: 1.4rem; /* Reduced font size */
      font-weight: 800;
      background: linear-gradient(90deg, var(--narbe-orange), var(--narbe-blue));
      -webkit-background-clip:text; 
      background-clip:text; 
      color:transparent;
    }

    .grid{
      display:grid; 
      gap:8px; /* Kept gap at 8px for balance */
      padding:12px; /* Slightly increased padding */
      background: linear-gradient(135deg, rgba(91,176,255,.05), rgba(255,92,0,.05));
      border-radius:var(--radius);
      border: 2px solid rgba(91,176,255,.2);
      box-shadow: 0 10px 40px rgba(0,0,0,.3), inset 0 2px 10px rgba(91,176,255,.1);
      flex-shrink: 0;
      overflow: hidden;
      margin: auto; /* Center the grid */
    }
    .cell-wrap{
      position:relative; 
      display:flex; 
      align-items:center; 
      justify-content:center; 
      background:transparent;
    }
    .card{
      width:100%; 
      height:100%; 
      display:flex; 
      align-items:center; 
      justify-content:center; 
      font-family:"Segoe UI Emoji", "Apple Color Emoji", system-ui; 
      background: linear-gradient(135deg, #2d3748, #1a202c); 
      color:transparent; 
      border:2px solid rgba(91,176,255,.2);
      border-radius:14px;
      cursor:pointer;
      transition: all .3s ease;
      box-shadow: 0 4px 12px rgba(0,0,0,.3);
      position: relative;
      overflow: hidden;
    }
    .card::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, transparent, rgba(91,176,255,.1), transparent);
      opacity: 0;
      transition: opacity .3s ease;
    }
    .card:hover:not(.inactive):not(.revealed):not(.cooldown){
      transform: translateY(-3px) scale(1.02);
      box-shadow: 0 8px 20px rgba(91,176,255,.2);
      border-color: rgba(91,176,255,.4);
    }
    .card:hover::before {
      opacity: 1;
    }
    .card.scan{
      background: linear-gradient(135deg, var(--yellow), #ffab00)!important; 
      outline:none; 
      box-shadow: 0 0 30px rgba(255,212,0,.5), 0 8px 20px rgba(0,0,0,.3);
      border-color: rgba(255,212,0,.6);
      transform: scale(1.08);
      animation: glow 1s ease infinite alternate;
    }
    @keyframes glow {
      from { box-shadow: 0 0 20px rgba(255,212,0,.4), 0 8px 20px rgba(0,0,0,.3); }
      to { box-shadow: 0 0 35px rgba(255,212,0,.6), 0 8px 20px rgba(0,0,0,.3); }
    }
    .card.revealed {
      animation: flip .5s ease;
      background: linear-gradient(135deg, #e0e7ff, #c7d2fe);
      border-color: rgba(91,176,255,.4);
      color: #1a202c !important;
    }
    .card.matched {
      color: #0b2239 !important;
    }
    @keyframes flip {
      0% { transform: rotateY(0deg); }
      50% { transform: rotateY(90deg); }
      100% { transform: rotateY(0deg); }
    }
    .card.cooldown {
      cursor: not-allowed;
      opacity: 0.7;
    }

    .inactive{
      background: linear-gradient(135deg, #1a1a1a, #0f0f0f);
      cursor: default;
      opacity: 0.2;
      border-color: rgba(255,255,255,.05);
    }

    .pause-overlay{
      position:absolute; 
      inset:0; 
      background:rgba(0,0,0,.9); 
      backdrop-filter: blur(10px);
      display:flex; 
      align-items:center; 
      justify-content:center;
      z-index: 1000;
      overflow: hidden; /* Remove scrolling */
    }
    .pause-card{
      background: linear-gradient(135deg, rgba(91,176,255,.15), rgba(255,92,0,.15));
      border: 2px solid rgba(91,176,255,.3);
      color:white; 
      padding:2rem; /* Reduced padding */
      border-radius:var(--radius); 
      display:flex; 
      flex-direction:column; 
      align-items:center; 
      min-width:min(90vw,450px); /* Reduced width */
      max-height: 80vh; /* Limit height */
      box-shadow: 0 20px 60px rgba(91,176,255,.2);
      overflow: hidden; /* Remove scrolling */
    }
    .pause-title{
      font-size:2rem; /* Reduced font size */
      margin-bottom:1.2rem; /* Reduced margin */
      background: linear-gradient(90deg, var(--narbe-orange), var(--narbe-blue));
      -webkit-background-clip:text; 
      background-clip:text; 
      color:transparent;
      font-weight: 800;
    }

    .result{
      font-family:"Arial Black"; 
      font-size:clamp(1.2rem,2.8vw,1.8rem); /* Reduced font size */
      color:#0b2239; 
      background: linear-gradient(135deg, #ffd400, #ffab00); 
      padding:0.8rem 1.5rem; /* Reduced padding */
      border-radius:var(--radius);
      box-shadow: 0 10px 30px rgba(255,212,0,.3);
      text-align: center;
      line-height: 1.4;
      margin-bottom: 0.8rem; /* Reduced margin */
      flex-shrink: 0;
    }

    .competitive-result {
      background: linear-gradient(135deg, rgba(91,176,255,.2), rgba(255,92,0,.2));
      border: 3px solid var(--yellow);
      color: var(--text);
      padding: 1.5rem; /* Reduced padding */
      border-radius: var(--radius);
      text-align: center;
      margin-bottom: 1.5rem; /* Reduced margin */
      box-shadow: 0 15px 40px rgba(255,212,0,.4);
      max-width: 80vw; /* Reduced width */
      flex-shrink: 0;
    }
    .competitive-result .winner {
      font-size: 2rem; /* Reduced font size */
      font-weight: 800;
      background: linear-gradient(90deg, var(--yellow), #ffab00);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      margin-bottom: 0.8rem; /* Reduced margin */
    }
    .competitive-result .final-score {
      font-size: 1.2rem; /* Reduced font size */
      color: var(--text);
      margin: 0.4rem 0; /* Reduced margin */
    }

    .hidden{display:none!important}

    /* Mobile responsive styles */
    @media (max-width: 768px) {
      .topbar {
        padding: 0.3rem 0.8rem;
        min-height: 45px;
        gap: 0.5rem;
      }
      
      .topbar-title {
        font-size: 12px;
        position: static; /* Remove absolute positioning on mobile */
      }
      
      .topbar-score {
        gap: 1rem;
        font-size: 12px;
      }
      
      .score-value-header {
        font-size: 14px;
      }
      
      .score-label-header {
        font-size: 9px;
      }
      
      .instructions-and-buttons {
        gap: 0.8rem;
        padding: 0.5rem;
      }
      
      .instructions {
        padding: 0.5rem 0.8rem;
        font-size: 0.75rem;
        max-width: 95%;
        min-width: 200px;
      }
      .instructions h3 {
        font-size: 0.8rem;
        margin-bottom: 0.3rem;
      }
      .instructions p {
        font-size: 0.68rem;
        margin: 0.15rem 0;
      }
      
      .btn{
        padding: 0.4rem 1rem;
        font-size: 0.85rem;
        margin: 0.15rem 0;
        min-width: 130px;
        min-height: 42px;
        max-width: 90vw;
      }
      
      .grid{
        gap: 2px;
        padding: 4px;
        margin: 0 auto; /* Ensure centering */
        box-sizing: border-box;
        justify-self: center; /* Grid self-centering */
      }
      
      .card{
        border-radius: 6px;
        min-height: 30px;
        font-size: 0.8rem;
      }
      
      .screen{
        padding: 0.25rem;
      }
    }

    /* Landscape mobile orientation - side-by-side layout */
    @media (max-width: 768px) and (orientation: landscape) {
      .instructions-and-buttons {
        flex-direction: row;
        align-items: flex-start;
        justify-content: center;
        gap: 1rem;
        height: 100%;
      }
      
      .instructions {
        flex: 0 0 auto;
        max-width: 35%;
        min-width: 200px;
        margin: 0;
        font-size: 0.65rem;
        padding: 0.4rem 0.6rem;
      }
      
      .instructions h3 {
        font-size: 0.7rem;
        margin-bottom: 0.2rem;
      }
      
      .instructions p {
        font-size: 0.6rem;
        margin: 0.1rem 0;
      }
      
      .menu-buttons-container {
        flex: 0 0 auto;
        gap: 0.3rem;
      }
      
      .btn {
        padding: 0.3rem 0.8rem;
        font-size: 0.8rem;
        min-width: 120px;
        min-height: 36px;
        margin: 0.1rem 0;
      }
      
      /* Ensure game grid stays centered in landscape */
      .center {
        align-items: center;
        justify-content: center;
      }
      
      .grid {
        margin: 0 auto;
        justify-self: center;
      }
    }

    /* Extra small mobile devices */
    @media (max-width: 480px) {
      .instructions {
        padding: 0.4rem 0.5rem;
        font-size: 0.7rem;
        min-width: 180px;
      }
      
      .instructions h3 {
        font-size: 0.75rem;
      }
      
      .instructions p {
        font-size: 0.6rem;
      }
      
      .btn{
        padding: 0.35rem 0.7rem;
        font-size: 0.8rem;
        min-width: 110px;
        margin: 0.1rem 0;
      }
      
      .card{
        min-height: 28px;
        border-radius: 4px;
        font-size: 0.7rem;
      }
      
      .grid{
        gap: 1px; /* Minimal gap for small screens */
        padding: 2px; /* Minimal padding */
      }
      
      .score-panel {
        padding: 0.3rem 0.4rem;
        gap: 0.4rem;
      }
      
      .score-value {
        font-size: 0.9rem;
      }
      
      /* Specific adjustments for landscape on very small screens */
      @media (orientation: landscape) {
        .title {
          font-size: clamp(0.9rem, 2.5vw, 1.2rem);
          margin: 0.1rem 0 0.2rem;
        }
        
        .btn {
          padding: 0.2rem 0.5rem;
          font-size: 0.7rem;
          min-width: 80px;
          min-height: 28px;
          margin: 0.05rem 0;
        }
        
        .instructions {
          padding: 0.2rem 0.3rem;
          font-size: 0.55rem;
        }
        
        .instructions h3 {
          font-size: 0.6rem;
        }
        
        .instructions p {
          font-size: 0.5rem;
        }
      }
    }

    /* Extra small mobile devices */
    @media (max-width: 480px) {
      .title{
        font-size:clamp(1.8rem,9vw,2.5rem);
      }
      
      .btn{
        padding:0.5rem 1rem;
        font-size:0.9rem;
        min-width: 120px;
      }
      
      .card{
        min-height: 30px;
        border-radius:6px;
      }
      
      .grid{
        gap:3px;
        padding:6px;
      }
    }
  </style>
</head>
<body>
  <div class="app" id="app">
    <div class="topbar">
      <div class="topbar-title">✨ Concentration Memory Game ✨</div>
      <div class="topbar-score"></div>
    </div>
    <div class="screen" id="screen"></div>
  </div>

  <script>
  // Web Speech TTS - Modified to cancel previous speech
  const speak = (text) => {
    const synth = window.speechSynthesis;
    if (!synth) return;
    
    // Cancel any ongoing speech immediately
    synth.cancel();
    
    // Speak the new text
    const utterance = new SpeechSynthesisUtterance(String(text));
    utterance.rate = 1.0;
    utterance.pitch = 1.0;
    utterance.volume = 1.0;
    synth.speak(utterance);
  };

  const $ = s => document.querySelector(s);
  const el = (t,c,txt)=>{ const e=document.createElement(t); if(c) e.className=c; if(txt!=null) e.textContent=txt; return e; };

  // Unique symbol-object pairs - correct names without color descriptions
  const SYMBOLS = [
    ["🍎","Apple"],["🌊","Ocean"],["🌲","Tree"],["🍇","Grapes"],
    ["⭐","Star"],["☀️","Sun"],["🧊","Ice"],["🎃","Pumpkin"],
    ["🌑","Moon"],["🍓","Strawberry"],["⛰️","Mountain"],["🥥","Coconut"],
    ["☁️","Cloud"],["🍋","Lemon"],["🔥","Fire"],["🌺","Flower"],
    ["🦋","Butterfly"],["🥝","Kiwi"],["👑","Crown"],["🌽","Corn"],
    ["💎","Diamond"],["🍊","Orange"],["🌸","Blossom"],["🍄","Mushroom"],
    ["🌙","Crescent"],["🍀","Clover"],["🏀","Basketball"],["🎨","Palette"]
  ];
  
  const NAME_MAP = {
    "🍎":"Apple","🌊":"Ocean","🌲":"Tree","🍇":"Grapes",
    "⭐":"Star","☀️":"Sun","🧊":"Ice","🎃":"Pumpkin",
    "🌑":"Moon","🍓":"Strawberry","⛰️":"Mountain","🥥":"Coconut",
    "☁️":"Cloud","🍋":"Lemon","🔥":"Fire","🌺":"Flower",
    "🦋":"Butterfly","🥝":"Kiwi","👑":"Crown","🌽":"Corn",
    "💎":"Diamond","🍊":"Orange","🌸":"Blossom","🍄":"Mushroom",
    "🌙":"Crescent","🍀":"Clover","🏀":"Basketball","🎨":"Palette"
  };

  const State = {
    mode: 'main_menu', // main_menu, game, pause
    modeType: 'single', // single, two_casual, two_competitive
    currentPlayer: 1,
    matchColors: {1: '#48bb78', 2: '#ed64a6'},

    // competitive
    currentDifficulty: 'easy',
    points: {1:0, 2:0},
    difficultyPoints: {easy:1, medium:2, hard:3},
    winThreshold: 0,
    pairsFound: {1:0, 2:0},

    // grid
    rows: 0, cols: 0,
    cells: new Map(),
    inactiveIndex: null,
    firstSel: null,
    busy: false,
    matchedPairs: 0,
    startTime: 0,
    moveCount: 0,
    cooldownActive: false,

    // scanning
    scanMode: 'row',
    currentRow: 0, currentCol: 0,
    scanStarted: false, // NEW: tracks if scanning has started this game
    inDeadzone: false, // NEW: tracks if we're in the deadzone
    menuButtons: [], menuScanIndex: 0,
    instructionsFocused: false,
    pauseButtons: [], pauseScanIndex: 0, pauseScanned: false,

    // timing
    spaceDebounce: 1.0,
    lastSpaceScanTime: 0,
    spaceHeld:false, spaceStart:0, spaceBackward:false, spaceTimer:null,
    returnHeld:false, returnStart:0, returnTimer:null, pauseTriggered:false,
    returnDebounce: 1.0, lastReturnTime: 0,
    
    // best scores tracking
    bestScores: {}
  };

  // Load best scores from localStorage
  function loadBestScores() {
    try {
      const stored = localStorage.getItem('concentrationBestScores');
      if (stored) {
        State.bestScores = JSON.parse(stored);
      } else {
        State.bestScores = { easy: null, medium: null, hard: null };
      }
    } catch(e) {
      State.bestScores = { easy: null, medium: null, hard: null };
    }
  }

  // Save best scores to localStorage
  function saveBestScores() {
    try {
      localStorage.setItem('concentrationBestScores', JSON.stringify(State.bestScores));
    } catch(e) {
      // localStorage might not be available
    }
  }

  // Check if current score is better than best
  function checkBestScore(difficulty, time, moves) {
    const current = State.bestScores[difficulty];
    const score = { time: Math.floor(time), moves: moves };
    
    if (!current) {
      State.bestScores[difficulty] = score;
      saveBestScores();
      return true;
    }
    
    // Better if fewer moves, or same moves but faster time
    if (moves < current.moves || (moves === current.moves && time < current.time)) {
      State.bestScores[difficulty] = score;
      saveBestScores();
      return true;
    }
    
    return false;
  }

  // UI helpers
  function buttonWithTTS(label, onClick){ 
    const b = el('button','btn'); 
    b.textContent = label; 
    b.onclick = onClick; 
    b.addEventListener('mouseenter',()=>{
      window.speechSynthesis.cancel(); // Cancel before speaking
      speak(label);
    }); 
    return b; 
  }
  function key(r,c){ return r+','+c; }

  // Menus
  function renderPlayerModeMenu(){
    State.mode = 'main_menu';
    
    // Update header title to show game name
    const topbarTitle = document.querySelector('.topbar-title');
    if (topbarTitle) {
      topbarTitle.textContent = '🧠 CONCENTRATION 🧠';
    }
    
    // Clear any score info from header
    const topbarScore = document.querySelector('.topbar-score');
    if (topbarScore) {
      topbarScore.innerHTML = '';
    }
    
    const screen = $('#screen'); screen.innerHTML='';
    const center = el('div','center');
    
    // Create flexible layout container
    const menuContainer = el('div', 'main-menu-container');
    const instructionsAndButtons = el('div', 'instructions-and-buttons');
    
    // Instructions box
    const instructions = el('div', 'instructions');
    instructions.innerHTML = `
      <h3>How to Play</h3>
      <p>🎯 Find matching pairs of cards by flipping them over</p>
      <p>⏱️ Complete the game in the fewest moves and fastest time</p>
      <p>🎮 Use spacebar to scan, return to select</p>
      <p>⏸️ Hold return for 3 seconds to pause</p>
      <p>🏆 Competitive: First to 5 points wins (Easy=1pt, Medium=2pts, Hard=3pts)</p>
    `;
    instructions.onclick = () => {
      speak("How to play Concentration. Find matching pairs of cards by flipping them over. Complete the game in the fewest moves and fastest time for the best score. Use spacebar to scan through options. Press return to select. Hold return for 3 seconds to pause the game. In competitive mode, first player to reach 5 points wins. Easy difficulty gives 1 point, Medium gives 2 points, Hard gives 3 points.");
    };
    instructions.addEventListener('mouseenter', () => speak("Instructions"));
    
    // Create buttons container
    const buttonsContainer = el('div', 'menu-buttons-container');
    State.menuButtons = [
      buttonWithTTS('Single Player', ()=> selectMode('single')),
      buttonWithTTS('Two Player Casual', ()=> selectMode('two_casual')),
      buttonWithTTS('Two Player Competitive', ()=> selectMode('two_competitive')),
      buttonWithTTS('Exit', ()=> exitApp())
    ];
    buttonsContainer.append(...State.menuButtons);
    
    // Assemble layout
    instructionsAndButtons.appendChild(instructions);
    instructionsAndButtons.appendChild(buttonsContainer);
    menuContainer.appendChild(instructionsAndButtons);
    center.appendChild(menuContainer);
    
    State.menuScanIndex = 0;
    State.instructionsFocused = false;
    updateMenuScan();
    screen.appendChild(center);
  }
  
  function updateMenuScan(){ 
    const instructions = document.querySelector('.instructions');
    if (instructions) {
      instructions.classList.toggle('scan', State.instructionsFocused);
    }
    State.menuButtons.forEach((b,i)=> b.classList.toggle('scan', !State.instructionsFocused && i===State.menuScanIndex)); 
    
    // Cancel previous speech before speaking new item
    window.speechSynthesis.cancel();
    
    if (State.instructionsFocused) {
      speak("Instructions. Press return to hear them.");
    } else {
      speak(State.menuButtons[State.menuScanIndex].textContent);
    }
  }
  
  function menuScanForward(){ 
    if (!State.instructionsFocused && State.menuScanIndex === State.menuButtons.length - 1) {
      State.instructionsFocused = true;
    } else if (State.instructionsFocused) {
      State.instructionsFocused = false;
      State.menuScanIndex = 0;
    } else {
      State.menuScanIndex = (State.menuScanIndex+1)%State.menuButtons.length;
    }
    updateMenuScan();
  }
  
  function menuScanBackward(){ 
    if (State.instructionsFocused) {
      State.instructionsFocused = false;
      State.menuScanIndex = State.menuButtons.length - 1;
    } else if (State.menuScanIndex === 0) {
      State.instructionsFocused = true;
    } else {
      State.menuScanIndex = (State.menuScanIndex-1+State.menuButtons.length)%State.menuButtons.length;
    }
    updateMenuScan();
  }

  function selectMode(mode){
    State.modeType = mode;
    if(mode==='two_competitive'){
      State.currentDifficulty = 'easy';
      State.points = {1:0,2:0};
      State.currentPlayer = 1;
      speak("Competitive mode. First to five points on easy. Player One's turn.");
      startGame('easy');
    } else {
      renderDifficultyMenu();
    }
  }

  function renderDifficultyMenu(){
    State.mode = 'main_menu';
    const screen = $('#screen'); screen.innerHTML='';
    const center = el('div','center');
    const title = el('div','title','SELECT DIFFICULTY');
    center.appendChild(title);
    State.menuButtons = [
      buttonWithTTS('Easy', ()=> startGame('easy')),
      buttonWithTTS('Medium', ()=> startGame('medium')),
      buttonWithTTS('Hard', ()=> startGame('hard')),
      buttonWithTTS('Back', ()=> renderPlayerModeMenu())
    ];
    State.menuScanIndex = 0;
    State.instructionsFocused = false;
    updateMenuScan();
    center.append(...State.menuButtons);
    $('#screen').appendChild(center);
  }

  // Game
  function startGame(difficulty){
    State.mode = 'game'; State.scanMode='row';
    State.scanStarted = false; // Reset scanning for new game
    State.inDeadzone = false;

    // rows and cols per difficulty
    const dims = { easy:[4,4], medium:[4,5], hard:[6,5] }[difficulty];
    State.rows = dims[0]; State.cols = dims[1];
    State.currentDifficulty = difficulty;

    State.cells = new Map(); State.firstSel = null; State.busy=false; State.matchedPairs=0;
    State.pairsFound = {1:0,2:0};
    State.moveCount = 0;
    State.cooldownActive = false;

    const totalCells = State.rows * State.cols;
    let inactive = null; let usable = totalCells;
    if(totalCells % 2 === 1){ inactive = Math.floor(Math.random()*totalCells); usable -= 1; }
    State.inactiveIndex = inactive;

    const pairs = Math.floor(usable/2);
    const shuffled = [...SYMBOLS].sort(()=>Math.random()-0.5).slice(0,pairs);
    const deck = [...shuffled, ...shuffled].sort(()=>Math.random()-0.5);
    State.deck = deck; // Store the deck for persistence during resize

    // compute threshold for competitive majority
    if(State.modeType==='two_competitive'){
      const numPairs = Math.floor(usable/2);
      State.winThreshold = Math.floor(numPairs/2) + 1;
    }

    const screen = $('#screen'); screen.innerHTML='';
    const center = el('div','center');

    // Move score/timer to header instead of main area
    const topbarScore = document.querySelector('.topbar-score');
    const topbarTitle = document.querySelector('.topbar-title');
    
    if (topbarTitle) {
      topbarTitle.textContent = `🧠 ${difficulty.toUpperCase()} 🧠`;
    }
    
    if (topbarScore) {
      topbarScore.innerHTML = '';
      if(State.modeType==='two_competitive'){
        const p1Score = el('div', 'score-item-header');
        p1Score.innerHTML = `<div class="score-label-header">Player 1</div><div class="score-value-header">${State.points[1]}</div>`;
        const p2Score = el('div', 'score-item-header');
        p2Score.innerHTML = `<div class="score-label-header">Player 2</div><div class="score-value-header">${State.points[2]}</div>`;
        topbarScore.append(p1Score, p2Score);
      } else if(State.modeType==='single') {
        const movesDiv = el('div', 'score-item-header');
        movesDiv.innerHTML = `<div class="score-label-header">Moves</div><div class="score-value-header" id="move-counter">0</div>`;
        const timeDiv = el('div', 'score-item-header');
        timeDiv.innerHTML = `<div class="score-label-header">Time</div><div class="score-value-header" id="timer">00:00</div>`;
        topbarScore.append(movesDiv, timeDiv);
      }
    }

    // Mobile-responsive grid sizing - no score panel needed now
    const isMobile = window.innerWidth <= 768;
    const topbarHeight = 54;
    const screenPadding = isMobile ? 4 : 20;
    const centerPadding = isMobile ? 4 : 20;
    
    const availableHeight = window.innerHeight - topbarHeight - screenPadding - centerPadding;
    const availableWidth = window.innerWidth - (isMobile ? 8 : 40);
    
    // Grid sizing with mobile support
    const gridPadding = isMobile ? 4 : 24; // Much smaller padding on mobile
    const cellGap = isMobile ? 2 : 8; // Much smaller gap on mobile
    
    // Calculate maximum possible cell size
    const maxCellWidth = Math.floor((availableWidth - (gridPadding * 2) - (cellGap * (State.cols - 1))) / State.cols);
    const maxCellHeight = Math.floor((availableHeight - (gridPadding * 2) - (cellGap * (State.rows - 1))) / State.rows);
    
    // Mobile-optimized cell sizing
    let cellWidth = maxCellWidth;
    let cellHeight = maxCellHeight;
    
    if(isMobile) {
      // Mobile-specific sizing with better hard mode support
      if(difficulty === 'hard') {
        // Hard mode (6x5) on mobile: prioritize fitting everything on screen
        cellWidth = Math.min(maxCellWidth, 50); // Smaller for 6 columns
        cellHeight = Math.min(maxCellHeight, 40);
        
        // Ensure minimum tap targets but prioritize fitting
        cellWidth = Math.max(cellWidth, 35);
        cellHeight = Math.max(cellHeight, 30);
      } else {
        // Easy/medium on mobile
        cellWidth = Math.min(maxCellWidth, 70);
        cellHeight = Math.min(maxCellHeight, 70);
        cellWidth = Math.max(cellWidth, 50);
        cellHeight = Math.max(cellHeight, 45);
      }
    } else {
      // Desktop sizing (existing logic)
      if(difficulty === 'hard') {
        cellWidth = Math.min(maxCellWidth, 200);
        cellHeight = Math.min(maxCellHeight, 150);
        cellWidth = Math.max(cellWidth, 80);
        cellHeight = Math.max(cellHeight, 60);
      } else {
        const targetRatio = 1.3;
        if(cellWidth / cellHeight > targetRatio) {
          cellWidth = Math.floor(cellHeight * targetRatio);
        } else if(cellHeight / cellWidth > targetRatio) {
          cellHeight = Math.floor(cellWidth * targetRatio);
        }
        cellWidth = Math.min(cellWidth, 180);
        cellHeight = Math.min(cellHeight, 160);
        cellWidth = Math.max(cellWidth, 70);
        cellHeight = Math.max(cellHeight, 60);
      }
    }
    
    const grid = el('div','grid');
    grid.style.gridTemplateColumns = `repeat(${State.cols}, ${cellWidth}px)`;
    grid.style.gridTemplateRows = `repeat(${State.rows}, ${cellHeight}px)`;
    grid.style.gap = `${cellGap}px`;

    let idx = 0;
    for(let r=0;r<State.rows;r++){
      for(let c=0;c<State.cols;c++){
        const wrap = el('div','cell-wrap');
        const lin = r*State.cols + c;
        if(inactive!==null && lin===inactive){
          const filler = el('div','card inactive','');
          wrap.appendChild(filler);
        } else {
          const [sym,color] = State.deck[idx++];
          const card = el('button','card');
          card.dataset.r=r; card.dataset.c=c;
          card.onclick = ()=> selectCard(r,c);
          wrap.appendChild(card);
          State.cells.set(key(r,c), {value:[sym,color], revealed:false, matched:false, matchedBy:null, el:card});
        }
        grid.appendChild(wrap);
      }
    }

    center.appendChild(grid);
    screen.appendChild(center);

    if(State.modeType.startsWith('two')) speak(`Player ${State.currentPlayer}'s turn`);

    State.currentRow=0; State.currentCol=0; 
    // Don't highlight anything until first spacebar press
    speak("Press spacebar to begin scanning");
    
    State.startTime = performance.now();
    
    // Start timer update for single player
    if(State.modeType === 'single') {
      updateTimer();
    }
  }

  function updateTimer() {
    if(State.mode !== 'game' || State.modeType !== 'single') return;
    const elapsed = Math.floor((performance.now() - State.startTime) / 1000);
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    const timeEl = $('#timer');
    if(timeEl) timeEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    requestAnimationFrame(updateTimer);
  }

  function updateScanHighlight(){
    State.cells.forEach((info, k)=>{
      const [r,c] = k.split(',').map(Number);
      
      // Only highlight if scanning has started and we're not in deadzone
      const active = State.scanStarted && !State.inDeadzone && 
        ((State.scanMode==='row' && r===State.currentRow) || 
         (State.scanMode==='col' && r===State.currentRow && c===State.currentCol));
      
      info.el.classList.toggle('scan', active);
      
      // Update matched card backgrounds
      if(info.matched) {
        const color = info.matchedBy===1? State.matchColors[1] : info.matchedBy===2? State.matchColors[2] : '#48bb78';
        info.el.style.background = `linear-gradient(135deg, ${color}, ${color}dd)`;
        info.el.style.borderColor = color;
        info.el.style.color = '#0b2239';
      }
      
      // set face - mobile-responsive emoji sizing for visibility
      if(info.revealed || info.matched){
        info.el.classList.add('revealed');
        // Mobile-responsive emoji size for better visibility
        const isMobile = window.innerWidth <= 768;
        const sizeMultiplier = isMobile ? 0.7 : 0.65; // Slightly larger on mobile for readability
        const size = Math.floor(Math.min(info.el.clientWidth, info.el.clientHeight) * sizeMultiplier);
        info.el.textContent = info.value[0];
        info.el.style.fontSize = Math.max(size, isMobile ? 16 : 20) + 'px'; // Minimum size for readability
        if (!info.matched) {
          info.el.style.color = '#1a202c';
        }
      } else {
        info.el.classList.remove('revealed');
        info.el.textContent = '';
        info.el.style.color = '';
      }
    });
  }

  // Card logic with cooldown
  function selectCard(r,c){
    if(State.busy || State.cooldownActive) return;
    const info = State.cells.get(key(r,c)); if(!info || info.matched || info.revealed) return;

    // Add move count for single player
    if(State.modeType === 'single') {
      State.moveCount++;
      const moveEl = $('#move-counter');
      if(moveEl) moveEl.textContent = State.moveCount;
    }

    // reveal with cooldown (reduced to 1 second)
    State.cooldownActive = true;
    State.cells.forEach(cell => cell.el.classList.add('cooldown'));
    setTimeout(() => {
      State.cooldownActive = false;
      State.cells.forEach(cell => cell.el.classList.remove('cooldown'));
    }, 1000); // Changed from 2000 to 1000 (1 second)

    info.revealed = true;
    info.el.classList.add('revealed');
    // Mobile-responsive emoji size for better visibility
    const isMobile = window.innerWidth <= 768;
    const sizeMultiplier = isMobile ? 0.7 : 0.65; // Slightly larger on mobile for readability
    const size = Math.floor(Math.min(info.el.clientWidth, info.el.clientHeight) * sizeMultiplier);
    info.el.textContent = info.value[0];
    info.el.style.fontSize = Math.max(size, isMobile ? 16 : 20) + 'px'; // Minimum size for readability
    info.el.style.color = '#1a202c';
    speak(NAME_MAP[info.value[0]] || info.value[1]);

    if(State.firstSel===null){
      State.firstSel = [r,c];
    } else {
      const [fr,fc] = State.firstSel;
      const first = State.cells.get(key(fr,fc));
      if(first && first.value[0]===info.value[0] && first.value[1]===info.value[1]){
        // match
        first.matched = true; info.matched = true;
        if(State.modeType!=='single'){
          first.matchedBy = State.currentPlayer; info.matchedBy = State.currentPlayer;
        }
        State.matchedPairs += 1;

        if(State.modeType==='two_competitive'){
          State.pairsFound[State.currentPlayer] += 1;
          if(State.pairsFound[State.currentPlayer] >= State.winThreshold){
            return handleRoundEnd(State.currentPlayer);
          }
        }

        setTimeout(()=> speak("That's a match! Great job!"), 100);
        tintMatched(fr,fc); tintMatched(r,c);

        if(State.modeType.startsWith('two')) speak(`Player ${State.currentPlayer}'s turn`);

        const totalPairs = Math.floor((State.rows*State.cols - (State.inactiveIndex===null?0:1))/2);
        if(State.matchedPairs === totalPairs){
          if(State.modeType==='two_competitive') return handleRoundEnd(State.currentPlayer);
          const elapsed = (performance.now() - State.startTime)/1000;
          
          // Determine winner for two_casual
          if(State.modeType === 'two_casual') {
            const winner = State.pairsFound[1] > State.pairsFound[2] ? 1 : 
                          State.pairsFound[2] > State.pairsFound[1] ? 2 : 0;
            return showCasualWinMessage(winner);
          }
          
          return showWinMessage(elapsed);
        }
      } else {
        // mismatch
        State.busy = true;
        setTimeout(()=> hideCards([fr,fc],[r,c]), 1500);
        if(State.modeType.startsWith('two')){
          State.currentPlayer = (State.currentPlayer===1?2:1);
          setTimeout(()=> speak(`Player ${State.currentPlayer}'s turn`), 1600);
        }
      }
      State.firstSel = null;
    }
    updateScanHighlight();
  }

  function tintMatched(r,c){
    const info = State.cells.get(key(r,c)); if(!info) return;
    const color = info.matchedBy===1? State.matchColors[1] : info.matchedBy===2? State.matchColors[2] : '#48bb78';
    info.el.style.background = `linear-gradient(135deg, ${color}, ${color}dd)`;
    info.el.style.borderColor = color;
    info.el.style.color = '#0b2239';
    info.el.style.transform = 'scale(0.95)';
  }

  function hideCards(p1,p2){
    [p1,p2].forEach(([r,c])=>{
      const info = State.cells.get(key(r,c)); if(!info) return;
      info.revealed = false; 
      info.el.classList.remove('revealed');
      info.el.textContent='';
      info.el.style.background = '';
      info.el.style.color = '';
    });
    State.busy = false;
  }

  // Pause
  let pauseLayer = null;
  function showPause(){
    if(State.mode!=='game') return;
    State.mode='pause'; State.pauseScanned=false; State.pauseScanIndex=0;
    const screen=$('#screen');
    pauseLayer = el('div','pause-overlay');
    const card = el('div','pause-card');
    const h = el('div','pause-title','Pause Menu');
    card.appendChild(h);
    State.pauseButtons = [
      buttonWithTTS('Continue Game', continueGame),
      buttonWithTTS('Return to Menu', renderPlayerModeMenu),
      buttonWithTTS('Exit', exitApp)
    ];
    card.append(...State.pauseButtons);
    pauseLayer.appendChild(card); screen.appendChild(pauseLayer);
  }
  function continueGame(){ if(pauseLayer){ pauseLayer.remove(); pauseLayer=null; } State.mode='game'; }
  function updatePauseScan(){ 
    State.pauseButtons.forEach((b,i)=> b.classList.toggle('scan', i===State.pauseScanIndex)); 
    
    // Cancel previous speech before speaking new item
    window.speechSynthesis.cancel();
    speak(State.pauseButtons[State.pauseScanIndex].textContent); 
  }
  function pauseScanForward(){ if(!State.pauseScanned){ State.pauseScanned=true; } else { State.pauseScanIndex=(State.pauseScanIndex+1)%State.pauseButtons.length; } updatePauseScan(); }
  function pauseScanBackward(){ if(!State.pauseScanned){ State.pauseScanned=true; } else { State.pauseScanIndex=(State.pauseScanIndex-1+State.pauseButtons.length)%State.pauseButtons.length; } updatePauseScan(); }

  // Win with scoring - updated for auto-return and best score checking
  function showWinMessage(elapsed){
    const screen=$('#screen'); screen.innerHTML='';
    const center=el('div','center');
    
    // Calculate score based on moves and time
    const minutes = Math.floor(elapsed / 60);
    const seconds = Math.floor(elapsed % 60);
    const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    
    // Check if this is a best score
    const isBest = checkBestScore(State.currentDifficulty, elapsed, State.moveCount);
    
    // Score calculation: lower moves and faster time = higher score
    const optimalMoves = State.rows * State.cols / 2; // Best possible
    const moveScore = Math.max(0, 1000 - (State.moveCount - optimalMoves) * 20);
    const timeScore = Math.max(0, 1000 - Math.floor(elapsed * 2));
    const totalScore = moveScore + timeScore;
    
    const msg = `🎉 Congratulations! You Won! 🎉`;
    const scoreMsg = `Time: ${timeString} | Moves: ${State.moveCount} | Score: ${totalScore}`;
    
    let speechText = `Congratulations! You won in ${timeString} with ${State.moveCount} moves. Your score is ${totalScore} points!`;
    
    if (isBest) {
      speechText += " This was your best game!";
    }
    speechText += " Returning to main menu.";
    
    speak(speechText);
    
    const res=el('div','result'); 
    res.innerHTML = `${msg}<div class="result-score">${scoreMsg}</div>`;
    if (isBest) {
      res.innerHTML += `<div style="color: var(--yellow); font-size: 1.2rem; margin-top: 0.5rem;">⭐ NEW BEST SCORE! ⭐</div>`;
    }
    res.innerHTML += `<div style="color: var(--muted); margin-top: 1rem;">Returning to menu in 5 seconds...</div>`;
    res.style.marginBottom='1rem';
    center.appendChild(res);
    screen.appendChild(center);
    
    // Auto return to menu after 5 seconds
    setTimeout(() => {
      renderPlayerModeMenu();
    }, 5000);
  }

  // New function for Two Player Casual win
  function showCasualWinMessage(winner) {
    const screen = $('#screen'); 
    screen.innerHTML = '';
    const center = el('div', 'center');
    
    const resultDiv = el('div', 'competitive-result');
    
    if (winner === 0) {
      // It's a tie
      resultDiv.innerHTML = `
        <div class="winner">🤝 It's a Tie! 🤝</div>
        <div class="final-score">Both players found ${State.pairsFound[1]} pairs!</div>
        <div style="margin-top: 1rem; color: var(--muted);">Returning to menu in 5 seconds...</div>
      `;
      speak(`It's a tie! Both players found ${State.pairsFound[1]} pairs. Returning to main menu.`);
    } else {
      // There's a winner
      resultDiv.innerHTML = `
        <div class="winner">🏆 Player ${winner} Wins! 🏆</div>
        <div class="final-score">Player 1: ${State.pairsFound[1]} pairs | Player 2: ${State.pairsFound[2]} pairs</div>
        <div style="margin-top: 1rem; color: var(--muted);">Returning to menu in 5 seconds...</div>
      `;
      speak(`Player ${winner} wins! Player 1 found ${State.pairsFound[1]} pairs, Player 2 found ${State.pairsFound[2]} pairs. Returning to main menu.`);
    }
    
    center.appendChild(resultDiv);
    screen.appendChild(center);
    
    // Auto return to menu after 5 seconds
    setTimeout(() => {
      renderPlayerModeMenu();
    }, 5000);
  }

  // Competitive
  function handleRoundEnd(winner){
    const pts = State.difficultyPoints[State.currentDifficulty];
    State.points[winner] += pts;
    
    if(State.points[winner] >= 5){ 
      // Show final competitive result
      showCompetitiveWin(winner);
      return;
    }

    speak(`Player ${winner} gets ${pts} ${pts>1?'points':'point'} for a ${State.currentDifficulty} win. Score is ${State.points[1]} to ${State.points[2]}.`);

    // cycle difficulty
    State.currentDifficulty = State.currentDifficulty==='easy' ? 'medium' : State.currentDifficulty==='medium' ? 'hard' : 'easy';
    State.currentPlayer = winner; // winner starts next
    speak(`Next game on ${State.currentDifficulty}. Player ${winner} starts.`);
    startGame(State.currentDifficulty);
  }

  function showCompetitiveWin(winner) {
    const screen = $('#screen'); 
    screen.innerHTML = '';
    const center = el('div', 'center');
    
    const resultDiv = el('div', 'competitive-result');
    resultDiv.innerHTML = `
      <div class="winner">🏆 Player ${winner} Wins! 🏆</div>
      <div class="final-score">Final Score: ${State.points[1]} - ${State.points[2]}</div>
      <div style="margin-top: 1rem; color: var(--muted);">Returning to menu in 6 seconds...</div>
    `;
    
    center.appendChild(resultDiv);
    screen.appendChild(center);
    
    speak(`Player ${winner} wins the match! Final score: Player 1 with ${State.points[1]} points, Player 2 with ${State.points[2]} points. Returning to main menu.`);
    
    // Wait 6 seconds then return to menu
    setTimeout(() => {
      State.points = {1:0, 2:0}; 
      State.currentDifficulty = 'easy'; 
      renderPlayerModeMenu();
    }, 6000);
  }

  function resetMatch(){ State.points={1:0,2:0}; State.currentDifficulty='easy'; renderPlayerModeMenu(); }

  // Key handling
  function onSpaceDown(){ if(!['game','main_menu','pause'].includes(State.mode)) return; if(State.spaceHeld) return; State.spaceHeld=true; State.spaceStart=performance.now(); State.spaceBackward=false; if(State.spaceTimer) clearTimeout(State.spaceTimer); State.spaceTimer=setTimeout(()=>{ if(State.spaceHeld){ State.spaceBackward=true; spaceBackwardLoop(); } },3000); }
  function spaceBackwardLoop(){ if(!State.spaceHeld) return; if(State.mode==='game') moveScanBackward(); else if(State.mode==='main_menu') menuScanBackward(); else pauseScanBackward(); State.spaceTimer=setTimeout(spaceBackwardLoop,2000); }
  function onSpaceUp(){ if(!['game','main_menu','pause'].includes(State.mode)) return; const dur = State.spaceStart?(performance.now()-State.spaceStart)/1000:0; if(State.spaceTimer){ clearTimeout(State.spaceTimer); State.spaceTimer=null; } const back=State.spaceBackward; State.spaceHeld=false; State.spaceBackward=false; if(!back && dur<3){ if(State.mode==='game') moveScanForward(); else if(State.mode==='main_menu') moveMenuForwardDebounced(); else pauseScanForward(); } }
  function moveMenuForwardDebounced(){ const now=performance.now()/1000; if(now-State.lastSpaceScanTime<State.spaceDebounce) return; State.lastSpaceScanTime=now; menuScanForward(); }

  function onReturnDown(){ if(State.mode!=='game') return; if(State.returnHeld) return; State.returnHeld=true; State.returnStart=performance.now(); State.pauseTriggered=false; if(State.returnTimer) clearTimeout(State.returnTimer); State.returnTimer=setTimeout(()=>{ if(State.returnHeld){ State.pauseTriggered=true; showPause(); } },3000); }
  function onReturnUp(){ if(State.returnTimer){ clearTimeout(State.returnTimer); State.returnTimer=null; } const now=performance.now()/1000; State.returnHeld=false; if(now-State.lastReturnTime < State.returnDebounce) return; State.lastReturnTime=now;
    if(State.mode==='main_menu'){ 
      if(State.instructionsFocused) {
        const instructions = document.querySelector('.instructions');
        if(instructions) instructions.click();
      } else {
        State.menuButtons[State.menuScanIndex]?.click();
      }
      return; 
    }
    if(State.mode==='pause'){ if(State.pauseScanned){ State.pauseButtons[State.pauseScanIndex]?.click(); } return; }
    if(State.mode==='game'){
      if(State.pauseTriggered){ State.pauseTriggered=false; return; }
      if(State.scanMode==='row'){
        State.scanMode='col';
        for(let c=0;c<State.cols;c++){ if(State.cells.has(key(State.currentRow,c))){ State.currentCol=c; break; } }
      } else {
        selectCard(State.currentRow, State.currentCol);
        State.scanMode='row';
      }
      updateScanHighlight();
    }
  }

  // Game scanning functions - NEW IMPLEMENTATION with deadzone and skipping matched cards
  function moveScanForward(){
    const now = performance.now()/1000;
    if(now - State.lastSpaceScanTime < State.spaceDebounce) return;
    State.lastSpaceScanTime = now;

    // Start scanning on first spacebar press
    if(!State.scanStarted) {
      State.scanStarted = true;
      State.inDeadzone = false;
      // Find first valid row with unmatched cards
      for(let r = 0; r < State.rows; r++) {
        let hasUnmatched = false;
        for(let c = 0; c < State.cols; c++) {
          const cell = State.cells.get(key(r, c));
          if(cell && !cell.matched) {
            hasUnmatched = true;
            break;
          }
        }
        if(hasUnmatched) {
          State.currentRow = r;
          break;
        }
      }
      updateScanHighlight();
      return;
    }

    if(State.scanMode==='row'){
      if(State.inDeadzone) {
        // Exit deadzone, go to first row with unmatched cards
        State.inDeadzone = false;
        for(let r = 0; r < State.rows; r++) {
          let hasUnmatched = false;
          for(let c = 0; c < State.cols; c++) {
            const cell = State.cells.get(key(r, c));
            if(cell && !cell.matched) {
              hasUnmatched = true;
              break;
            }
          }
          if(hasUnmatched) {
            State.currentRow = r;
            break;
          }
        }
      } else {
        // Move to next row with unmatched cards or enter deadzone
        let foundNextRow = false;
        for(let r = State.currentRow + 1; r < State.rows; r++) {
          let hasUnmatched = false;
          for(let c = 0; c < State.cols; c++) {
            const cell = State.cells.get(key(r, c));
            if(cell && !cell.matched) {
              hasUnmatched = true;
              break;
            }
          }
          if(hasUnmatched) {
            State.currentRow = r;
            foundNextRow = true;
            break;
          }
        }
        if(!foundNextRow) {
          State.inDeadzone = true;
        }
      }
    } else {
      // Move to next unmatched column in current row
      let startCol = State.currentCol;
      let found = false;
      
      // Try to find the next valid unmatched cell in this row
      for(let i = 1; i <= State.cols; i++){
        let nextCol = (State.currentCol + i) % State.cols;
        const cell = State.cells.get(key(State.currentRow, nextCol));
        if(cell && !cell.matched){
          State.currentCol = nextCol;
          found = true;
          
          // Check if we've looped back to or past the starting column
          if(nextCol <= startCol) {
            // We've completed the loop, switch back to row mode
            State.scanMode = 'row';
          }
          break;
        }
      }
      
      // If no valid unmatched cell found, switch back to row mode
      if(!found){
        State.scanMode = 'row';
      }
    }
    updateScanHighlight();
  }
  
  function moveScanBackward(){
    if(!State.scanStarted) {
      State.scanStarted = true;
      State.inDeadzone = false;
      // Find last valid row with unmatched cards
      for(let r = State.rows - 1; r >= 0; r--) {
        let hasUnmatched = false;
        for(let c = 0; c < State.cols; c++) {
          const cell = State.cells.get(key(r, c));
          if(cell && !cell.matched) {
            hasUnmatched = true;
            break;
          }
        }
        if(hasUnmatched) {
          State.currentRow = r;
          break;
        }
      }
      updateScanHighlight();
      return;
    }

    if(State.scanMode==='row'){
      if(State.inDeadzone) {
        // Exit deadzone, go to last row with unmatched cards
        State.inDeadzone = false;
        for(let r = State.rows - 1; r >= 0; r--) {
          let hasUnmatched = false;
          for(let c = 0; c < State.cols; c++) {
            const cell = State.cells.get(key(r, c));
            if(cell && !cell.matched) {
              hasUnmatched = true;
              break;
            }
          }
          if(hasUnmatched) {
            State.currentRow = r;
            break;
          }
        }
      } else {
        // Move to previous row with unmatched cards or enter deadzone
        let foundPrevRow = false;
        for(let r = State.currentRow - 1; r >= 0; r--) {
          let hasUnmatched = false;
          for(let c = 0; c < State.cols; c++) {
            const cell = State.cells.get(key(r, c));
            if(cell && !cell.matched) {
              hasUnmatched = true;
              break;
            }
          }
          if(hasUnmatched) {
            State.currentRow = r;
            foundPrevRow = true;
            break;
          }
        }
        if(!foundPrevRow) {
          State.inDeadzone = true;
        }
      }
    } else {
      // Move to previous unmatched column in current row
      let startCol = State.currentCol;
      let found = false;
      
      // Try to find the previous valid unmatched cell in this row
      for(let i = 1; i <= State.cols; i++){
        let prevCol = (State.currentCol - i + State.cols) % State.cols;
        const cell = State.cells.get(key(State.currentRow, prevCol));
        if(cell && !cell.matched){
          State.currentCol = prevCol;
          found = true;
          
          // Check if we've looped back to or past the starting column
          if(prevCol >= startCol) {
            // We've completed the loop, switch back to row mode
            State.scanMode = 'row';
          }
          break;
        }
      }
      
      // If no valid unmatched cell found, switch back to row mode
      if(!found){
        State.scanMode = 'row';
      }
    }
    updateScanHighlight();
  }

  // Keyboard listeners
  document.addEventListener('keydown', e=>{ if(e.code==='Space'){ e.preventDefault(); onSpaceDown(); } if(e.code==='Enter'){ e.preventDefault(); onReturnDown(); } });
  document.addEventListener('keyup', e=>{ if(e.code==='Space'){ e.preventDefault(); onSpaceUp(); } if(e.code==='Enter'){ e.preventDefault(); onReturnUp(); } });

  // Robust exit helper: communicates with parent to focus back button
  function exitApp(){
    try{
      // Try to message parent window to focus the back button
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({ action: 'focusBackButton' }, '*');
      }
      // Navigate to parent directory (Access-Hub root)
      location.href = '../index.html';
    }catch(err){
      // Fallback: try relative navigation
      try{
        window.location.replace('../index.html');
      }catch(_){
        // Last resort: go up one level
        window.location.href = '..';
      }
    }
  }

  // Handle window resize and orientation changes for mobile devices
  let resizeTimeout;
  function handleResize() {
    // Update viewport height custom property for mobile
    const vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
    
    // Debounce resize events
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      // Only regenerate grid if we're in game mode
      if (State.mode === 'game') {
        // Store current game state including symbol deck
        const gameState = {
          mode: State.mode,
          modeType: State.modeType,
          currentPlayer: State.currentPlayer,
          currentDifficulty: State.currentDifficulty,
          points: {...State.points},
          pairsFound: {...State.pairsFound},
          matchedPairs: State.matchedPairs,
          moveCount: State.moveCount,
          startTime: State.startTime,
          cells: new Map(State.cells),
          deck: [...State.deck], // Preserve the symbol deck
          rows: State.rows,
          cols: State.cols,
          inactiveIndex: State.inactiveIndex
        };
        
        // Regenerate the game layout with preserved symbols
        regenerateGameWithState(gameState);
      }
    }, 250); // Wait 250ms after resize stops
  }

  // Function to regenerate game layout while preserving symbols and state
  function regenerateGameWithState(gameState) {
    // Restore basic state
    State.mode = gameState.mode;
    State.modeType = gameState.modeType;
    State.currentPlayer = gameState.currentPlayer;
    State.currentDifficulty = gameState.currentDifficulty;
    State.points = gameState.points;
    State.pairsFound = gameState.pairsFound;
    State.matchedPairs = gameState.matchedPairs;
    State.moveCount = gameState.moveCount;
    State.startTime = gameState.startTime;
    State.deck = gameState.deck;
    State.rows = gameState.rows;
    State.cols = gameState.cols;
    State.inactiveIndex = gameState.inactiveIndex;

    // Clear current display
    const screen = $('#screen'); 
    screen.innerHTML = '';
    const center = el('div', 'center');

    // No score panel needed - using header now
    
    // Mobile-responsive grid sizing (same logic as startGame)
    const isMobile = window.innerWidth <= 768;
    const topbarHeight = 54;
    const screenPadding = isMobile ? 4 : 20;
    const centerPadding = isMobile ? 4 : 20;
    
    const availableHeight = window.innerHeight - topbarHeight - screenPadding - centerPadding;
    const availableWidth = window.innerWidth - (isMobile ? 8 : 40);

    // Improved grid sizing to prevent shrinking on orientation change
    const gridPadding = isMobile ? 4 : 24;
    const cellGap = isMobile ? 2 : 8;
    
    // Calculate maximum possible cell size
    const maxCellWidth = Math.floor((availableWidth - (gridPadding * 2) - (cellGap * (State.cols - 1))) / State.cols);
    const maxCellHeight = Math.floor((availableHeight - (gridPadding * 2) - (cellGap * (State.rows - 1))) / State.rows);
    
    // Use the same sizing logic as startGame to maintain consistency
    let cellWidth = maxCellWidth;
    let cellHeight = maxCellHeight;
    
    if(isMobile) {
      // Mobile-specific sizing with better hard mode support
      if(State.currentDifficulty === 'hard') {
        // Hard mode (6x5) on mobile: prioritize fitting everything on screen
        cellWidth = Math.min(maxCellWidth, 50); // Smaller for 6 columns
        cellHeight = Math.min(maxCellHeight, 40);
        
        // Ensure minimum tap targets but prioritize fitting
        cellWidth = Math.max(cellWidth, 35);
        cellHeight = Math.max(cellHeight, 30);
      } else {
        // Easy/medium on mobile
        cellWidth = Math.min(maxCellWidth, 70);
        cellHeight = Math.min(maxCellHeight, 70);
        cellWidth = Math.max(cellWidth, 50);
        cellHeight = Math.max(cellHeight, 45);
      }
    } else {
      // Desktop sizing (existing logic)
      if(State.currentDifficulty === 'hard') {
        cellWidth = Math.min(maxCellWidth, 200);
        cellHeight = Math.min(maxCellHeight, 150);
        cellWidth = Math.max(cellWidth, 80);
        cellHeight = Math.max(cellHeight, 60);
      } else {
        const targetRatio = 1.3;
        if(cellWidth / cellHeight > targetRatio) {
          cellWidth = Math.floor(cellHeight * targetRatio);
        } else if(cellHeight / cellWidth > targetRatio) {
          cellHeight = Math.floor(cellWidth * targetRatio);
        }
        cellWidth = Math.min(cellWidth, 180);
        cellHeight = Math.min(cellHeight, 160);
        cellWidth = Math.max(cellWidth, 70);
        cellHeight = Math.max(cellHeight, 60);
      }
    }

    // Create grid with preserved symbols
    const grid = el('div', 'grid');
    grid.style.cssText = `
      display: grid;
      grid-template-columns: repeat(${State.cols}, ${cellWidth}px);
      grid-template-rows: repeat(${State.rows}, ${cellHeight}px);
      gap: ${cellGap}px;
      padding: ${gridPadding}px;
      width: auto;
      height: auto;
      justify-content: center;
      align-content: center;
      max-width: 100vw;
      box-sizing: border-box;
    `;

    // Recreate cells with original symbols and restored states
    State.cells.clear();
    let idx = 0;
    for (let r = 0; r < State.rows; r++) {
      for (let c = 0; c < State.cols; c++) {
        const wrap = el('div', 'cell-wrap');
        const lin = r * State.cols + c;
        if (State.inactiveIndex !== null && lin === State.inactiveIndex) {
          const filler = el('div', 'card inactive', '');
          wrap.appendChild(filler);
        } else {
          const [sym, color] = State.deck[idx++];
          const card = el('button', 'card');
          card.dataset.r = r;
          card.dataset.c = c;
          card.onclick = () => selectCard(r, c);
          wrap.appendChild(card);
          State.cells.set(key(r, c), { value: [sym, color], revealed: false, matched: false, matchedBy: null, el: card });
        }
        grid.appendChild(wrap);
      }
    }

    // Restore cell states from gameState
    gameState.cells.forEach((info, cellKey) => {
      if (State.cells.has(cellKey)) {
        const currentCell = State.cells.get(cellKey);
        currentCell.revealed = info.revealed;
        currentCell.matched = info.matched;
        currentCell.matchedBy = info.matchedBy;
        
        // Update visual state
        const card = currentCell.el;
        if (info.revealed || info.matched) {
          const [sym, color] = currentCell.value;
          card.innerHTML = sym;
          card.style.background = color;
          card.style.color = '#fff';
        }
        if (info.matched) {
          card.classList.add('matched');
          if (info.matchedBy) {
            card.classList.add(`matched-by-${info.matchedBy}`);
          }
        }
      }
    });

    // No scorePanel needed - using header now
    center.appendChild(grid);
    screen.appendChild(center);

    // Update scan highlight and timers
    updateScanHighlight();
    if (State.modeType === 'single') {
      updateTimer();
    }
  }

  window.addEventListener('resize', handleResize);
  window.addEventListener('orientationchange', () => {
    // Wait a bit for orientation change to complete
    setTimeout(handleResize, 100);
  });

  // Set initial viewport height
  const setInitialVH = () => {
    const vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  };
  
  // Set VH on load and after DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setInitialVH);
  } else {
    setInitialVH();
  }

  // Boot
  loadBestScores(); // Load best scores on startup
  renderPlayerModeMenu();
  </script>
</body>
</html>
